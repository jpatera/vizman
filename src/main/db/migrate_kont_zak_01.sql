
-- !!!!  Do BEFORE tables are created:
SET COLLATION CZECH STRENGTH SECONDARY;



DROP SEQUENCE VIZMAN.VIZMAN_GLOBAL_SEQ IF EXISTS;

CREATE SEQUENCE IF NOT EXISTS VIZMAN.VIZMAN_GLOBAL_SEQ
  START WITH 1000001
  INCREMENT BY 10
  CACHE 50
;

COMMIT;

-- =============================================

DROP TABLE VIZMAN.CFGPROP IF EXISTS;

CREATE TABLE VIZMAN.CFGPROP (
	ID BIGINT NOT NULL,
	VERSION INTEGER NOT NULL,
	NAME VARCHAR(127) NOT NULL,
	VALUE VARCHAR(127),
	ORD INTEGER NOT NULL,
	LABEL VARCHAR(64) NOT NULL,
	DESCRIPTION VARCHAR(255),
	RO BOOLEAN,
	CONSTRAINT PK_CFGPROP PRIMARY KEY (NAME)
);



----------------------
-- Kalendare
----------------------

DROP TABLE VIZMAN.CALY IF EXISTS;

CREATE TABLE VIZMAN.CALY (
	ID BIGINT NOT NULL,
	VERSION INTEGER NOT NULL,
	CAL_YR INTEGER NOT NULL,
	PRAC_FOND_YR DECIMAL(6,1),
	CONSTRAINT PK_CALY PRIMARY KEY (ID)
);

CREATE UNIQUE INDEX VIZMAN.IDXQ_CALY_CAL_YR ON VIZMAN."CALY" (CAL_YR)
;

SELECT DISTINCT 300000 + ROK_UZAV, 0, ROK_UZAV, SUM(PRACFOND) FROM zavin.UZAV_
GROUP BY ROK_UZAV
ORDER BY ROK_UZAV DESC
;

INSERT INTO VIZMAN.CALY (ID, VERSION, CAL_YR, PRAC_FOND_YR)
	SELECT DISTINCT 100 * ROK_UZAV, 0, ROK_UZAV, SUM(PRACFOND) FROM zavin.UZAV_
	GROUP BY ROK_UZAV
;

COMMIT;


DROP TABLE VIZMAN.CALYM IF EXISTS;

CREATE TABLE VIZMAN.CALYM (
	ID BIGINT NOT NULL,
	VERSION INTEGER NOT NULL,
	CAL_YM INTEGER NOT NULL,
	PRAC_FOND_YM DECIMAL(6,1),
	CONSTRAINT PK_CALYM PRIMARY KEY (ID)
);

CREATE UNIQUE INDEX VIZMAN.IDXQ_CALYM_CAL_YM ON VIZMAN.CALYM (CAL_YM)
;

SELECT DISTINCT 100 * ROK_UZAV + MES_UZAV, 0, 100 * ROK_UZAV + MES_UZAV AS YM, SUM(PRACFOND) FROM zavin.UZAV_
	GROUP BY YM
	ORDER BY YM DESC
;

INSERT INTO VIZMAN.CALYM (ID, VERSION, CAL_YM, PRAC_FOND_YM)
	SELECT DISTINCT 100 * ROK_UZAV + MES_UZAV, 0, 100 * ROK_UZAV + MES_UZAV AS YM, SUM(PRACFOND) FROM zavin.UZAV_
	GROUP BY YM
	ORDER BY YM
;

COMMIT;

DELETE FROM VIZMAN.CALYM
WHERE ID / 100 = 2019
;

COMMIT;

SET @yr = '2019';
INSERT INTO VIZMAN.CALYM (ID, VERSION, CAL_YM)
(
SELECT 100 * YEAR(ymd) + MONTH(ymd), 0,  100 * YEAR(ymd) + MONTH(ymd)
FROM (
	SELECT CONVERT(CONCAT(@yr, '-1-1'), DATE) AS ymd UNION ALL
	SELECT CONVERT(CONCAT(@yr, '-2-1'), DATE) UNION ALL
	SELECT CONVERT(CONCAT(@yr, '-3-1'), DATE) UNION ALL
	SELECT CONVERT(CONCAT(@yr, '-4-1'), DATE) UNION ALL
	SELECT CONVERT(CONCAT(@yr, '-5-1'), DATE) UNION ALL
	SELECT CONVERT(CONCAT(@yr, '-6-1'), DATE) UNION ALL
	SELECT CONVERT(CONCAT(@yr, '-7-1'), DATE) UNION ALL
	SELECT CONVERT(CONCAT(@yr, '-8-1'), DATE) UNION ALL
	SELECT CONVERT(CONCAT(@yr, '-9-1'), DATE) UNION ALL
	SELECT CONVERT(CONCAT(@yr, '-10-1'), DATE) UNION ALL
	SELECT CONVERT(CONCAT(@yr, '-11-1'), DATE) UNION ALL
	SELECT CONVERT(CONCAT(@yr, '-12-1'), DATE) 
) yearmonth
)
ORDER BY ymd
;



DROP TABLE VIZMAN.CALY_HOL IF EXISTS;

CREATE TABLE VIZMAN.CALY_HOL (
	ID BIGINT NOT NULL,
	VERSION INTEGER NOT NULL,
	CAL_YR INTEGER NOT NULL,
	HOL_DATE DATE,
	HOL_TEXT VARCHAR(64),
	CONSTRAINT PK_CALYHOL PRIMARY KEY (ID)
);

CREATE UNIQUE INDEX VIZMAN.IDXQ_CALYHOL_CALYR_HOLDATE ON VIZMAN.CALY_HOL (CAL_YR, HOL_DATE)
;

INSERT INTO VIZMAN.CALY_HOL
(ID, VERSION, CAL_YR, HOL_DATE, HOL_TEXT)
SELECT DISTINCT
	CAL_ID, 0, CAL_YEAR, CAL_DATUM, CAL_SVTEXT FROM zavin.CAL_
	WHERE cal_sv = TRUE
ORDER BY CAL_DATUM DESC
;

COMMIT;



DELETE FROM VIZMAN.CALY_HOL
WHERE CAL_YR = 2019
;

COMMIT;

INSERT INTO VIZMAN.CALY_HOL	(ID, VERSION, CAL_YR, HOL_DATE, HOL_TEXT)
VALUES(5901, 0, 2019, '2019-01-01', 'Nový rok');

INSERT INTO VIZMAN.CALY_HOL	(ID, VERSION, CAL_YR, HOL_DATE, HOL_TEXT)
VALUES(5902, 0, 2019, '2019-04-19', 'Velký pátek');

INSERT INTO VIZMAN.CALY_HOL	(ID, VERSION, CAL_YR, HOL_DATE, HOL_TEXT)
VALUES(5903, 0, 2019, '2019-04-22', 'Velikonoèní pondìlí');

INSERT INTO VIZMAN.CALY_HOL	(ID, VERSION, CAL_YR, HOL_DATE, HOL_TEXT)
VALUES(5904, 0, 2019, '2019-05-01', 'Svátek práce');

INSERT INTO VIZMAN.CALY_HOL	(ID, VERSION, CAL_YR, HOL_DATE, HOL_TEXT)
VALUES(5905, 0, 2019, '2019-05-08', 'Den vítìzství');

INSERT INTO VIZMAN.CALY_HOL	(ID, VERSION, CAL_YR, HOL_DATE, HOL_TEXT)
VALUES(5906, 0, 2019, '2019-07-05', 'Cyril a Metodìj');

INSERT INTO VIZMAN.CALY_HOL	(ID, VERSION, CAL_YR, HOL_DATE, HOL_TEXT)
VALUES(5907, 0, 2019, '2019-07-06', 'Jan Hus');

INSERT INTO VIZMAN.CALY_HOL	(ID, VERSION, CAL_YR, HOL_DATE, HOL_TEXT)
VALUES(5908, 0, 2019, '2019-09-28', 'Den státnosti');

INSERT INTO VIZMAN.CALY_HOL	(ID, VERSION, CAL_YR, HOL_DATE, HOL_TEXT)
VALUES(5909, 0, 2019, '2019-10-28', 'Vznik Èeskoslovenska');

INSERT INTO VIZMAN.CALY_HOL	(ID, VERSION, CAL_YR, HOL_DATE, HOL_TEXT)
VALUES(5910, 0, 2019, '2019-11-17', 'Den boje za svobodu');

INSERT INTO VIZMAN.CALY_HOL	(ID, VERSION, CAL_YR, HOL_DATE, HOL_TEXT)
VALUES(5911, 0, 2019, '2019-12-24', 'Štìdrý den');

INSERT INTO VIZMAN.CALY_HOL	(ID, VERSION, CAL_YR, HOL_DATE, HOL_TEXT)
VALUES(5912, 0, 2019, '2019-12-25', '1, svátek vánoèní');

INSERT INTO VIZMAN.CALY_HOL	(ID, VERSION, CAL_YR, HOL_DATE, HOL_TEXT)
VALUES(5913, 0, 2019, '2019-12-26', '2. svátek vánoèní');

COMMIT;


----------------------------------
-- Pracovni fondy
----------------------------------

SET @ym = 201901;
UPDATE VIZMAN.CALYM c
SET PRAC_FOND_YM =
8 * (SELECT (20 + COUNT(*))
	FROM (
		SELECT DATEADD(DAY, 28, CONVERT(CONCAT(CONVERT(@ym / 100, VARCHAR(4)), '-', CONVERT(@ym % 100, VARCHAR(2)), '-01'), DATE)) AS DDD UNION
		SELECT DATEADD(DAY, 29, CONVERT(CONCAT(CONVERT(@ym / 100, VARCHAR(4)), '-', CONVERT(@ym % 100, VARCHAR(2)), '-01'), DATE)) UNION
		SELECT DATEADD(DAY, 30, CONVERT(CONCAT(CONVERT(@ym / 100, VARCHAR(4)), '-', CONVERT(@ym % 100, VARCHAR(2)), '-01'), DATE)) 
	) AS pf
	WHERE DAY(DDD) > 28
	    AND DAY_OF_WEEK(DDD) <> 1
	    AND DAY_OF_WEEK(DDD) <> 7
)
- 8 * (	SELECT  COUNT(*)
	FROM VIZMAN.CALY_HOL ch
		WHERE 100 * YEAR(ch.HOL_DATE) + MONTH(ch.HOL_DATE) = @ym
			AND DAY_OF_WEEK(ch.HOL_DATE) <> 1
			AND DAY_OF_WEEK(ch.HOL_DATE) <> 7
)
WHERE c.CAL_YM = @ym
;
SET @ym = 201902;
UPDATE VIZMAN.CALYM c
SET PRAC_FOND_YM =
8 * (SELECT (20 + COUNT(*))
	FROM (
		SELECT DATEADD(DAY, 28, CONVERT(CONCAT(CONVERT(@ym / 100, VARCHAR(4)), '-', CONVERT(@ym % 100, VARCHAR(2)), '-01'), DATE)) AS DDD UNION
		SELECT DATEADD(DAY, 29, CONVERT(CONCAT(CONVERT(@ym / 100, VARCHAR(4)), '-', CONVERT(@ym % 100, VARCHAR(2)), '-01'), DATE)) UNION
		SELECT DATEADD(DAY, 30, CONVERT(CONCAT(CONVERT(@ym / 100, VARCHAR(4)), '-', CONVERT(@ym % 100, VARCHAR(2)), '-01'), DATE)) 
	) AS pf
	WHERE DAY(DDD) > 28
	    AND DAY_OF_WEEK(DDD) <> 1
	    AND DAY_OF_WEEK(DDD) <> 7
)
- 8 * (	SELECT  COUNT(*)
	FROM VIZMAN.CALY_HOL ch
		WHERE 100 * YEAR(ch.HOL_DATE) + MONTH(ch.HOL_DATE) = @ym
			AND DAY_OF_WEEK(ch.HOL_DATE) <> 1
			AND DAY_OF_WEEK(ch.HOL_DATE) <> 7
)
WHERE c.CAL_YM = @ym
;
SET @ym = 201903;
UPDATE VIZMAN.CALYM c
SET PRAC_FOND_YM =
8 * (SELECT (20 + COUNT(*))
	FROM (
		SELECT DATEADD(DAY, 28, CONVERT(CONCAT(CONVERT(@ym / 100, VARCHAR(4)), '-', CONVERT(@ym % 100, VARCHAR(2)), '-01'), DATE)) AS DDD UNION
		SELECT DATEADD(DAY, 29, CONVERT(CONCAT(CONVERT(@ym / 100, VARCHAR(4)), '-', CONVERT(@ym % 100, VARCHAR(2)), '-01'), DATE)) UNION
		SELECT DATEADD(DAY, 30, CONVERT(CONCAT(CONVERT(@ym / 100, VARCHAR(4)), '-', CONVERT(@ym % 100, VARCHAR(2)), '-01'), DATE)) 
	) AS pf
	WHERE DAY(DDD) > 28
	    AND DAY_OF_WEEK(DDD) <> 1
	    AND DAY_OF_WEEK(DDD) <> 7
)
- 8 * (	SELECT  COUNT(*)
	FROM VIZMAN.CALY_HOL ch
		WHERE 100 * YEAR(ch.HOL_DATE) + MONTH(ch.HOL_DATE) = @ym
			AND DAY_OF_WEEK(ch.HOL_DATE) <> 1
			AND DAY_OF_WEEK(ch.HOL_DATE) <> 7
)
WHERE c.CAL_YM = @ym
;
SET @ym = 201904;
UPDATE VIZMAN.CALYM c
SET PRAC_FOND_YM =
8 * (SELECT (20 + COUNT(*))
	FROM (
		SELECT DATEADD(DAY, 28, CONVERT(CONCAT(CONVERT(@ym / 100, VARCHAR(4)), '-', CONVERT(@ym % 100, VARCHAR(2)), '-01'), DATE)) AS DDD UNION
		SELECT DATEADD(DAY, 29, CONVERT(CONCAT(CONVERT(@ym / 100, VARCHAR(4)), '-', CONVERT(@ym % 100, VARCHAR(2)), '-01'), DATE)) UNION
		SELECT DATEADD(DAY, 30, CONVERT(CONCAT(CONVERT(@ym / 100, VARCHAR(4)), '-', CONVERT(@ym % 100, VARCHAR(2)), '-01'), DATE)) 
	) AS pf
	WHERE DAY(DDD) > 28
	    AND DAY_OF_WEEK(DDD) <> 1
	    AND DAY_OF_WEEK(DDD) <> 7
)
- 8 * (	SELECT  COUNT(*)
	FROM VIZMAN.CALY_HOL ch
		WHERE 100 * YEAR(ch.HOL_DATE) + MONTH(ch.HOL_DATE) = @ym
			AND DAY_OF_WEEK(ch.HOL_DATE) <> 1
			AND DAY_OF_WEEK(ch.HOL_DATE) <> 7
)
WHERE c.CAL_YM = @ym
;
SET @ym = 201905;
UPDATE VIZMAN.CALYM c
SET PRAC_FOND_YM =
8 * (SELECT (20 + COUNT(*))
	FROM (
		SELECT DATEADD(DAY, 28, CONVERT(CONCAT(CONVERT(@ym / 100, VARCHAR(4)), '-', CONVERT(@ym % 100, VARCHAR(2)), '-01'), DATE)) AS DDD UNION
		SELECT DATEADD(DAY, 29, CONVERT(CONCAT(CONVERT(@ym / 100, VARCHAR(4)), '-', CONVERT(@ym % 100, VARCHAR(2)), '-01'), DATE)) UNION
		SELECT DATEADD(DAY, 30, CONVERT(CONCAT(CONVERT(@ym / 100, VARCHAR(4)), '-', CONVERT(@ym % 100, VARCHAR(2)), '-01'), DATE)) 
	) AS pf
	WHERE DAY(DDD) > 28
	    AND DAY_OF_WEEK(DDD) <> 1
	    AND DAY_OF_WEEK(DDD) <> 7
)
- 8 * (	SELECT  COUNT(*)
	FROM VIZMAN.CALY_HOL ch
		WHERE 100 * YEAR(ch.HOL_DATE) + MONTH(ch.HOL_DATE) = @ym
			AND DAY_OF_WEEK(ch.HOL_DATE) <> 1
			AND DAY_OF_WEEK(ch.HOL_DATE) <> 7
)
WHERE c.CAL_YM = @ym
;
SET @ym = 201906;
UPDATE VIZMAN.CALYM c
SET PRAC_FOND_YM =
8 * (SELECT (20 + COUNT(*))
	FROM (
		SELECT DATEADD(DAY, 28, CONVERT(CONCAT(CONVERT(@ym / 100, VARCHAR(4)), '-', CONVERT(@ym % 100, VARCHAR(2)), '-01'), DATE)) AS DDD UNION
		SELECT DATEADD(DAY, 29, CONVERT(CONCAT(CONVERT(@ym / 100, VARCHAR(4)), '-', CONVERT(@ym % 100, VARCHAR(2)), '-01'), DATE)) UNION
		SELECT DATEADD(DAY, 30, CONVERT(CONCAT(CONVERT(@ym / 100, VARCHAR(4)), '-', CONVERT(@ym % 100, VARCHAR(2)), '-01'), DATE)) 
	) AS pf
	WHERE DAY(DDD) > 28
	    AND DAY_OF_WEEK(DDD) <> 1
	    AND DAY_OF_WEEK(DDD) <> 7
)
- 8 * (	SELECT  COUNT(*)
	FROM VIZMAN.CALY_HOL ch
		WHERE 100 * YEAR(ch.HOL_DATE) + MONTH(ch.HOL_DATE) = @ym
			AND DAY_OF_WEEK(ch.HOL_DATE) <> 1
			AND DAY_OF_WEEK(ch.HOL_DATE) <> 7
)
WHERE c.CAL_YM = @ym
;
SET @ym = 201907;
UPDATE VIZMAN.CALYM c
SET PRAC_FOND_YM =
8 * (SELECT (20 + COUNT(*))
	FROM (
		SELECT DATEADD(DAY, 28, CONVERT(CONCAT(CONVERT(@ym / 100, VARCHAR(4)), '-', CONVERT(@ym % 100, VARCHAR(2)), '-01'), DATE)) AS DDD UNION
		SELECT DATEADD(DAY, 29, CONVERT(CONCAT(CONVERT(@ym / 100, VARCHAR(4)), '-', CONVERT(@ym % 100, VARCHAR(2)), '-01'), DATE)) UNION
		SELECT DATEADD(DAY, 30, CONVERT(CONCAT(CONVERT(@ym / 100, VARCHAR(4)), '-', CONVERT(@ym % 100, VARCHAR(2)), '-01'), DATE)) 
	) AS pf
	WHERE DAY(DDD) > 28
	    AND DAY_OF_WEEK(DDD) <> 1
	    AND DAY_OF_WEEK(DDD) <> 7
)
- 8 * (	SELECT  COUNT(*)
	FROM VIZMAN.CALY_HOL ch
		WHERE 100 * YEAR(ch.HOL_DATE) + MONTH(ch.HOL_DATE) = @ym
			AND DAY_OF_WEEK(ch.HOL_DATE) <> 1
			AND DAY_OF_WEEK(ch.HOL_DATE) <> 7
)
WHERE c.CAL_YM = @ym
;
SET @ym = 201908;
UPDATE VIZMAN.CALYM c
SET PRAC_FOND_YM =
8 * (SELECT (20 + COUNT(*))
	FROM (
		SELECT DATEADD(DAY, 28, CONVERT(CONCAT(CONVERT(@ym / 100, VARCHAR(4)), '-', CONVERT(@ym % 100, VARCHAR(2)), '-01'), DATE)) AS DDD UNION
		SELECT DATEADD(DAY, 29, CONVERT(CONCAT(CONVERT(@ym / 100, VARCHAR(4)), '-', CONVERT(@ym % 100, VARCHAR(2)), '-01'), DATE)) UNION
		SELECT DATEADD(DAY, 30, CONVERT(CONCAT(CONVERT(@ym / 100, VARCHAR(4)), '-', CONVERT(@ym % 100, VARCHAR(2)), '-01'), DATE)) 
	) AS pf
	WHERE DAY(DDD) > 28
	    AND DAY_OF_WEEK(DDD) <> 1
	    AND DAY_OF_WEEK(DDD) <> 7
)
- 8 * (	SELECT  COUNT(*)
	FROM VIZMAN.CALY_HOL ch
		WHERE 100 * YEAR(ch.HOL_DATE) + MONTH(ch.HOL_DATE) = @ym
			AND DAY_OF_WEEK(ch.HOL_DATE) <> 1
			AND DAY_OF_WEEK(ch.HOL_DATE) <> 7
)
WHERE c.CAL_YM = @ym
;
SET @ym = 201909;
UPDATE VIZMAN.CALYM c
SET PRAC_FOND_YM =
8 * (SELECT (20 + COUNT(*))
	FROM (
		SELECT DATEADD(DAY, 28, CONVERT(CONCAT(CONVERT(@ym / 100, VARCHAR(4)), '-', CONVERT(@ym % 100, VARCHAR(2)), '-01'), DATE)) AS DDD UNION
		SELECT DATEADD(DAY, 29, CONVERT(CONCAT(CONVERT(@ym / 100, VARCHAR(4)), '-', CONVERT(@ym % 100, VARCHAR(2)), '-01'), DATE)) UNION
		SELECT DATEADD(DAY, 30, CONVERT(CONCAT(CONVERT(@ym / 100, VARCHAR(4)), '-', CONVERT(@ym % 100, VARCHAR(2)), '-01'), DATE)) 
	) AS pf
	WHERE DAY(DDD) > 28
	    AND DAY_OF_WEEK(DDD) <> 1
	    AND DAY_OF_WEEK(DDD) <> 7
)
- 8 * (	SELECT  COUNT(*)
	FROM VIZMAN.CALY_HOL ch
		WHERE 100 * YEAR(ch.HOL_DATE) + MONTH(ch.HOL_DATE) = @ym
			AND DAY_OF_WEEK(ch.HOL_DATE) <> 1
			AND DAY_OF_WEEK(ch.HOL_DATE) <> 7
)
WHERE c.CAL_YM = @ym
;
SET @ym = 201910;
UPDATE VIZMAN.CALYM c
SET PRAC_FOND_YM =
8 * (SELECT (20 + COUNT(*))
	FROM (
		SELECT DATEADD(DAY, 28, CONVERT(CONCAT(CONVERT(@ym / 100, VARCHAR(4)), '-', CONVERT(@ym % 100, VARCHAR(2)), '-01'), DATE)) AS DDD UNION
		SELECT DATEADD(DAY, 29, CONVERT(CONCAT(CONVERT(@ym / 100, VARCHAR(4)), '-', CONVERT(@ym % 100, VARCHAR(2)), '-01'), DATE)) UNION
		SELECT DATEADD(DAY, 30, CONVERT(CONCAT(CONVERT(@ym / 100, VARCHAR(4)), '-', CONVERT(@ym % 100, VARCHAR(2)), '-01'), DATE)) 
	) AS pf
	WHERE DAY(DDD) > 28
	    AND DAY_OF_WEEK(DDD) <> 1
	    AND DAY_OF_WEEK(DDD) <> 7
)
- 8 * (	SELECT  COUNT(*)
	FROM VIZMAN.CALY_HOL ch
		WHERE 100 * YEAR(ch.HOL_DATE) + MONTH(ch.HOL_DATE) = @ym
			AND DAY_OF_WEEK(ch.HOL_DATE) <> 1
			AND DAY_OF_WEEK(ch.HOL_DATE) <> 7
)
WHERE c.CAL_YM = @ym
;
SET @ym = 201911;
UPDATE VIZMAN.CALYM c
SET PRAC_FOND_YM =
8 * (SELECT (20 + COUNT(*))
	FROM (
		SELECT DATEADD(DAY, 28, CONVERT(CONCAT(CONVERT(@ym / 100, VARCHAR(4)), '-', CONVERT(@ym % 100, VARCHAR(2)), '-01'), DATE)) AS DDD UNION
		SELECT DATEADD(DAY, 29, CONVERT(CONCAT(CONVERT(@ym / 100, VARCHAR(4)), '-', CONVERT(@ym % 100, VARCHAR(2)), '-01'), DATE)) UNION
		SELECT DATEADD(DAY, 30, CONVERT(CONCAT(CONVERT(@ym / 100, VARCHAR(4)), '-', CONVERT(@ym % 100, VARCHAR(2)), '-01'), DATE)) 
	) AS pf
	WHERE DAY(DDD) > 28
	    AND DAY_OF_WEEK(DDD) <> 1
	    AND DAY_OF_WEEK(DDD) <> 7
)
- 8 * (	SELECT  COUNT(*)
	FROM VIZMAN.CALY_HOL ch
		WHERE 100 * YEAR(ch.HOL_DATE) + MONTH(ch.HOL_DATE) = @ym
			AND DAY_OF_WEEK(ch.HOL_DATE) <> 1
			AND DAY_OF_WEEK(ch.HOL_DATE) <> 7
)
WHERE c.CAL_YM = @ym
;
SET @ym = 201912;
UPDATE VIZMAN.CALYM c
SET PRAC_FOND_YM =
8 * (SELECT (20 + COUNT(*))
	FROM (
		SELECT DATEADD(DAY, 28, CONVERT(CONCAT(CONVERT(@ym / 100, VARCHAR(4)), '-', CONVERT(@ym % 100, VARCHAR(2)), '-01'), DATE)) AS DDD UNION
		SELECT DATEADD(DAY, 29, CONVERT(CONCAT(CONVERT(@ym / 100, VARCHAR(4)), '-', CONVERT(@ym % 100, VARCHAR(2)), '-01'), DATE)) UNION
		SELECT DATEADD(DAY, 30, CONVERT(CONCAT(CONVERT(@ym / 100, VARCHAR(4)), '-', CONVERT(@ym % 100, VARCHAR(2)), '-01'), DATE)) 
	) AS pf
	WHERE DAY(DDD) > 28
	    AND DAY_OF_WEEK(DDD) <> 1
	    AND DAY_OF_WEEK(DDD) <> 7
)
- 8 * (	SELECT  COUNT(*)
	FROM VIZMAN.CALY_HOL ch
		WHERE 100 * YEAR(ch.HOL_DATE) + MONTH(ch.HOL_DATE) = @ym
			AND DAY_OF_WEEK(ch.HOL_DATE) <> 1
			AND DAY_OF_WEEK(ch.HOL_DATE) <> 7
)
WHERE c.CAL_YM = @ym
;

COMMIT;

UPDATE VIZMAN.CALY
SET PRAC_FOND_YR =
	(SELECT SUM(PRAC_FOND_YM) FROM CALYM
		WHERE CAL_YM / 100 = 2019
	)
WHERE CAL_YR = 2019
;

COMMIT;


----------------------
-- Cinnosti
----------------------

DROP TABLE VIZMAN.CIN IF EXISTS;

CREATE TABLE VIZMAN.CIN (
	ID BIGINT NOT NULL,
	VERSION INTEGER NOT NULL,
	PORADI SMALLINT NOT NULL,
	AKCE_TYP VARCHAR(2),
	AKCE VARCHAR(32),
	CIN_KOD VARCHAR(2),
	CINNOST VARCHAR(24),
	CALCPRAC BOOLEAN,
	TMP VARCHAR(1),
	CONSTRAINT PK_CIN PRIMARY KEY (ID)
);

CREATE UNIQUE INDEX VIZMAN.IDXQ_CIN_PORADI ON VIZMAN."CIN" (PORADI)
;


DROP TABLE VIZMAN.PERSON IF EXISTS;

CREATE TABLE VIZMAN.PERSON (
	ID BIGINT NOT NULL,
	VERSION INTEGER NOT NULL,
	STATE VARCHAR(16),
	USERNAME VARCHAR(32),
	PASSWORD VARCHAR(32),
	JMENO VARCHAR(64),
	PRIJMENI VARCHAR(64),
	NASTUP DATE,
	VYSTUP DATE,
	SAZBA DECIMAL(19,2),
	CONSTRAINT PK_PERSON PRIMARY KEY (ID)
);



DROP TABLE VIZMAN.ROLE IF EXISTS;

CREATE TABLE VIZMAN."ROLE" (
	ID BIGINT NOT NULL,
	VERSION INTEGER NOT NULL,
	DESCRIPTION VARCHAR(255),
	NAME VARCHAR(255),
	CONSTRAINT PK_ROLE PRIMARY KEY (ID)
);

CREATE UNIQUE INDEX VIZMAN.IDXQ_ROLE_NAME ON VIZMAN."ROLE" (NAME)
;


DROP TABLE VIZMAN.PERSON_ROLE IF EXISTS;

CREATE TABLE VIZMAN.PERSON_ROLE (
	PERSON_ID BIGINT NOT NULL,
	ROLE_ID BIGINT NOT NULL,
	CONSTRAINT PK_PERSON_ROLE PRIMARY KEY (PERSON_ID,ROLE_ID),
	CONSTRAINT FK_PERSON_ROLE_ROLE FOREIGN KEY (ROLE_ID) REFERENCES VIZMAN."ROLE"(ID) ON DELETE RESTRICT ON UPDATE RESTRICT,
	CONSTRAINT FK_PERSON_ROLE_PERSON FOREIGN KEY (PERSON_ID) REFERENCES VIZMAN.PERSON(ID) ON DELETE RESTRICT ON UPDATE RESTRICT
);
-- CREATE UNIQUE INDEX IDXQ_PK_PERSON_ROLE ON VIZMAN.PERSON_ROLE (PERSON_ID,ROLE_ID);
-- CREATE INDEX IDX_FK_PERSON_ROLE_ROLE ON VIZMAN.PERSON_ROLE (ROLE_ID);
-- CREATE INDEX IDX_FK_PERSON_ROLE_PERSON ON VIZMAN.PERSON_ROLE (PERSON_ID);


DROP TABLE VIZMAN.ROLE_PERM IF EXISTS;

CREATE TABLE VIZMAN.ROLE_PERM (
	ROLE_ID BIGINT NOT NULL,
	PERM VARCHAR(255),
	CONSTRAINT FK_ROLE_PERM_ROLE FOREIGN KEY (ROLE_ID) REFERENCES VIZMAN."ROLE"(ID) ON DELETE RESTRICT ON UPDATE RESTRICT
);

CREATE INDEX VIZMAN.IDX_ROLE_PERM_ROLE_ID ON VIZMAN.ROLE_PERM (ROLE_ID)
;


--  =============================================



INSERT INTO VIZMAN.CFGPROP (ID, VERSION, NAME, VALUE, ORD, LABEL, DESCRIPTION, RO)
VALUES(1, 1, 'app.locale', 'cs_CZ', 110, 'Národní tøídìní a formáty', 'Národní tøídìní a formáty', true)
;


INSERT INTO VIZMAN.CFGPROP (ID, VERSION, NAME, VALUE, ORD, LABEL, DESCRIPTION, RO)
VALUES(2, 1, 'app.document.root.local', 'L:\VizMan', 130, 'Koøenový adresáø pro dokumeny (stanice)', 'Koøenový adresáø pro dokumeny z pohledu pracovních stanic', false)
;

INSERT INTO VIZMAN.CFGPROP (ID, VERSION, NAME, VALUE, ORD, LABEL, DESCRIPTION, RO)
VALUES(3, 1, 'app.document.root.server', '\\pc-server7\VizMan', 130, 'Koøenový adresáø pro dokumeny (server)', 'Koøenový adresáø pro dokumeny z pohledu serveru', false)
;


INSERT INTO VIZMAN.CFGPROP (ID, VERSION, NAME, VALUE, ORD, LABEL, DESCRIPTION, RO)
VALUES(4, 1, 'app.project.root.local', 'S:\PROJEKT', 120, 'Koøenový adresáø pro projekty (stanice)', 'Koøenový adresáø pro projekty z pohledu pracovních stanic', false)
;

INSERT INTO VIZMAN.CFGPROP (ID, VERSION, NAME, VALUE, ORD, LABEL, DESCRIPTION, RO)
VALUES(5, 1, 'app.project.root.server', '\\pc-server7\PROJEKT', 120, 'Koøenový adresáø pro projekty (server)', 'Koøenový adresáø pro projekty z pohledu serveru', false)
;


INSERT INTO VIZMAN.CFGPROP (ID, VERSION, NAME, VALUE, ORD, LABEL, DESCRIPTION, RO)
VALUES(6, 1, 'app.koef.pojist', '0.35', 140, 'Koeficient pojištìní', 'Používá se pøi výpoètech vyhodnocovacích tabulek', false)
;

INSERT INTO VIZMAN.CFGPROP (ID, VERSION, NAME, VALUE, ORD, LABEL, DESCRIPTION, RO)
VALUES(7, 1, 'app.koef.rezie', '0.8', 150, 'Koeficient režie', 'Používá se pøi výpoètech vyhodnocovacích tabulek', false)
;


COMMIT;

-- ---------------------------------------------


INSERT INTO VIZMAN.CIN
(ID, VERSION, PORADI, AKCE_TYP, CIN_KOD, AKCE, CINNOST, CALCPRAC, TMP)
SELECT CIN_ID, 1, PORADI, CIN_T1, CIN_T2, AKCE, CINNOST, CALCPRAC, TMP 
FROM ZAVIN.CIN_;

COMMIT;

UPDATE VIZMAN.CIN
	SET CIN_KOD = 'KP'
	WHERE PORADI = 45
;

COMMIT;

UPDATE VIZMAN.CIN
	SET CIN_KOD = 'XD'
	WHERE PORADI = 50
;

COMMIT;

UPDATE VIZMAN.CIN
	SET AKCE_TYP = 'A'
	WHERE PORADI = 100
;
UPDATE VIZMAN.CIN
	SET CALCPRAC = true
	WHERE PORADI = 100
;

COMMIT;

UPDATE VIZMAN.CIN
	SET CIN_KOD = 'dc'
	WHERE PORADI = 80
;

UPDATE VIZMAN.CIN
	SET CIN_KOD = 'dp'
	WHERE PORADI = 90
;

COMMIT;

UPDATE VIZMAN.CIN
	SET AKCE_TYP = 'F'
	WHERE CIN_KOD = 'do' OR CIN_KOD = 'dp' OR CIN_KOD = 'ne' OR CIN_KOD = 'nv'  
;

COMMIT;

UPDATE VIZMAN.CIN
	SET CINNOST = 'Obìd oprav. (zrušeno)'
	WHERE PORADI = 105
;

COMMIT;

CREATE UNIQUE INDEX VIZMAN.IDXQ_CIN_CINKOD ON VIZMAN."CIN" (CIN_KOD)
;

COMMIT;

-- ---------------------------------------------


INSERT INTO VIZMAN.PERSON
(ID, VERSION, STATE, JMENO, PRIJMENI, PASSWORD, USERNAME, NASTUP, VYSTUP, SAZBA)
VALUES(1001, 0, 'HIDDEN', 'Admin', 'Systemak', 'admin', 'admin', NULL, NULL, 0);

INSERT INTO VIZMAN.PERSON
(ID, VERSION, STATE, JMENO, PRIJMENI, PASSWORD, USERNAME, NASTUP, VYSTUP, SAZBA)
VALUES(1002, 0, 'HIDDEN', 'User', 'Bìžný user', 'user', 'user', NULL, NULL, 0);

INSERT INTO VIZMAN.PERSON
(ID, VERSION, STATE, USERNAME, PASSWORD, JMENO, PRIJMENI, NASTUP, VYSTUP, SAZBA)
VALUES(1003, 0, 'HIDDEN', 'manag', 'manag', 'Manager', 'Zkušený', NULL, NULL, 0);

INSERT INTO VIZMAN.PERSON
(ID, VERSION, STATE, JMENO, PRIJMENI, PASSWORD, USERNAME, NASTUP, VYSTUP, SAZBA)
SELECT USER_ID, 1,
CASE
    WHEN USER_NAME = 'Studentova' THEN 'ACTIVE'
    WHEN USER_LEVEL = 1 THEN 'DISABLED'
    ELSE 'ACTIVE'
END,
USER_FIRST, USER_LAST, USER_PWD, USER_LOGIN, USER_NASTUP, USER_VYSTUP, USER_SAZBA 
FROM ZAVIN.USR_;

COMMIT;


UPDATE VIZMAN.PERSON p
SET STATUS = 
(SELECT 
  CASE
    WHEN u.USER_LOGIN = 'Studentova' THEN 'ACTIVE'
    WHEN u.USER_LEVEL = 1 THEN 'DISABLED'
    ELSE 'ACTIVE'
  END
  FROM ZAVIN.USR_ u
  WHERE u.USER_LOGIN = p.USERNAME
)  
;
 

-- ---------------------------------------------


INSERT INTO VIZMANDB.VIZMAN."ROLE" (ID, VERSION, DESCRIPTION, NAME)
VALUES(10001, 1, 'Administrátor - všechna existující oprávnìní', 'ROLE_ADMIN');

INSERT INTO VIZMANDB.VIZMAN."ROLE" (ID, VERSION, DESCRIPTION, NAME)
VALUES(10002, 1, 'Uživatel - bìžná oprávnìní', 'ROLE_USER');

INSERT INTO VIZMANDB.VIZMAN."ROLE" (ID, VERSION, DESCRIPTION, NAME)
VALUES(10003, 1, 'Manager - jako ROLE_USER plus fakturace a honoráøe', 'ROLE_MANAGER');

COMMIT;


INSERT INTO VIZMAN.ROLE_PERM
(ROLE_ID, PERM)
VALUES(10001, 'MODIFY_ALL');
INSERT INTO VIZMAN.ROLE_PERM
(ROLE_ID, PERM)
VALUES(10001, 'VIEW_ALL');
INSERT INTO VIZMAN.ROLE_PERM
(ROLE_ID, PERM)
VALUES(10002, 'ZAK_BASIC_READ');
INSERT INTO VIZMAN.ROLE_PERM
(ROLE_ID, PERM)
VALUES(10002, 'DOCH_USE');
INSERT INTO VIZMAN.ROLE_PERM
(ROLE_ID, PERM)
VALUES(10003, 'ZAK_BASIC_MODIFY');
INSERT INTO VIZMAN.ROLE_PERM
(ROLE_ID, PERM)
VALUES(10003, 'ZAK_EXT_MODIFY');
INSERT INTO VIZMAN.ROLE_PERM
(ROLE_ID, PERM)
VALUES(10003, 'ZAK_EXT_READ');
INSERT INTO VIZMAN.ROLE_PERM
(ROLE_ID, PERM)
VALUES(10003, 'ZAK_BASIC_READ');
INSERT INTO VIZMAN.ROLE_PERM
(ROLE_ID, PERM)
VALUES(10003, 'DOCH_USE');

COMMIT;

INSERT INTO VIZMAN.PERSON_ROLE
(PERSON_ID, ROLE_ID)
VALUES(1001, 10001);
INSERT INTO VIZMAN.PERSON_ROLE
(PERSON_ID, ROLE_ID)
VALUES(1002, 10002);
INSERT INTO VIZMAN.PERSON_ROLE
(PERSON_ID, ROLE_ID)
VALUES(1003, 10003);

COMMIT;

--  =============================================
--    CREATE TABLES - KONT, ZAK, FAKT...
--  =============================================


-- TRUNCATE TABLE vizman.kont;

DROP TABLE VIZMAN.KONTDOC IF EXISTS;
DROP TABLE VIZMAN.ZAKDOC IF EXISTS;
DROP TABLE VIZMAN.FAKT IF EXISTS;
DROP TABLE VIZMAN.ZAK IF EXISTS;
DROP TABLE VIZMAN.KONT IF EXISTS;
DROP TABLE VIZMAN.KLIENT IF EXISTS;

DROP SEQUENCE VIZMAN.KONT_SEQ IF EXISTS;
DROP SEQUENCE VIZMAN.ZAK_SEQ IF EXISTS;


DROP SEQUENCE VIZMAN.KONT_SEQ_IMP IF EXISTS;

CREATE SEQUENCE VIZMAN.KONT_SEQ_IMP
  START WITH 10001
  INCREMENT BY 1
  CACHE 50
;


DROP SEQUENCE VIZMAN.ZAK_SEQ_IMP IF EXISTS;

CREATE SEQUENCE VIZMAN.ZAK_SEQ_IMP
  START WITH 20001
  INCREMENT BY 1
  CACHE 50
;

COMMIT;


DROP SEQUENCE VIZMAN.KLIENT_SEQ_IMP IF EXISTS;

CREATE SEQUENCE VIZMAN.KLIENT_SEQ_IMP
  START WITH 30001
  INCREMENT BY 1
  CACHE 50
;

COMMIT;


DROP TABLE VIZMAN.KLIENT IF EXISTS;

CREATE TABLE VIZMAN.KLIENT (
	ID BIGINT NOT NULL,
	VERSION INTEGER NOT NULL,
	TYP VARCHAR(5) NOT NULL,
	NAME VARCHAR(127),
	NOTE VARCHAR(127),
	ID_ZAK BIGINT,
	DATE_CREATE DATE,
	DATETIME_UPDATE DATETIME AS NOW() NOT NULL,
	CONSTRAINT PK_KLIENT PRIMARY KEY (ID)
);



DROP TABLE VIZMAN.KONT IF EXISTS;

CREATE TABLE VIZMAN.KONT (
	ID BIGINT NOT NULL,
	VERSION INTEGER NOT NULL,
	UUID UUID NOT NULL
				COMMENT 'Inicialni duvod pro UUID je potreba unikatniho identifikatoru nezavisleho na autoamtickem DB ID, potrebneho pro tree grid',
	TYP VARCHAR(5) NOT NULL,
	CKONT VARCHAR(16),
	ROK SMALLINT,
	ARCH BOOLEAN,
	INVESTOR VARCHAR(127),
	OBJEDNATEL VARCHAR(127),
	MENA VARCHAR(5) NOT NULL,
	TEXT VARCHAR(127),
	FOLDER VARCHAR(127),
	ID_KLIENT BIGINT,	
	TMP VARCHAR(8),	-- Mozna uplne vypustit?	
	DATE_CREATE DATE,
	DATETIME_UPDATE DATETIME AS NOW() NOT NULL,
	CONSTRAINT PK_KONT PRIMARY KEY (ID)
);


CREATE INDEX VIZMAN.IDX_KONT_OBJEDNATEL ON VIZMAN.KONT (OBJEDNATEL)
;
CREATE UNIQUE INDEX VIZMAN.IDXQ_KONT_CKONT ON VIZMAN.KONT (CKONT)
;

COMMIT;


-- DROP SEQUENCE VIZMAN.KONT_SEQ;

-- CREATE SEQUENCE IF NOT EXISTS VIZMAN.KONT_SEQ
--   START WITH 1
--   INCREMENT BY 1
--   CACHE 1
--;


DROP TABLE VIZMAN.ZAK IF EXISTS;

CREATE TABLE VIZMAN.ZAK (
	ID BIGINT NOT NULL,
	VERSION INTEGER NOT NULL,
	UUID UUID NOT NULL
				COMMENT 'Inicialni duvod je potreba unikatniho identifikatoru pro potreby tree grid, nezavisleho na DB ID ',
	TYP VARCHAR(5) NOT NULL,
	CKONT_ORIG VARCHAR(16)
				COMMENT 'Cislo kontraktu - jen pro uvodni import za Zavinu, jinak null',
	CZAK INTEGER,
	ROK SMALLINT,
	ARCH BOOLEAN,
	SKUPINA VARCHAR(3),
	TEXT VARCHAR(127),
	FOLDER VARCHAR(127),
	HONORAR DECIMAL(19,2) NOT NULL DEFAULT 0,
	ID_KONT BIGINT,
	R1 DECIMAL(19,2),
	R2 DECIMAL(19,2),
	R3 DECIMAL(19,2),
	R4 DECIMAL(19,2),
	ROZPRAC DECIMAL(19,2),
	R_ZAL INTEGER,
	RM DECIMAL(19,2),
	TMP VARCHAR(8),	-- Mozna uplne vypustit?
--	TYP_DOKLADU VARCHAR(5),
--	X BOOLEAN,
	ROKMESZAD VARCHAR(8),
	DATE_CREATE DATE,
	DATETIME_UPDATE DATETIME AS NOW() NOT NULL,
	CONSTRAINT PK_ZAK PRIMARY KEY (ID),
	CONSTRAINT FK_ZAK_KONT FOREIGN KEY (ID_KONT) REFERENCES VIZMAN.KONT(ID) ON DELETE RESTRICT ON UPDATE RESTRICT
);

-- CREATE INDEX IDX_FK_PODZAK_ZAK ON VIZMAN.PODZAK (ID_ZAK);
CREATE UNIQUE INDEX VIZMAN.IDXQ_ZAK_IDKONT_CZAK ON VIZMAN.ZAK (ID_KONT, CZAK)
;

COMMIT;

-- DROP SEQUENCE VIZMAN.ZAK_SEQ;

-- CREATE SEQUENCE IF NOT EXISTS VIZMAN.ZAK_SEQ
--   START WITH 1
--   INCREMENT BY 1
--   CACHE 1
-- ;


DROP TABLE VIZMAN.KONTDOC IF EXISTS;

CREATE TABLE VIZMAN.KONTDOC (
	ID BIGINT NOT NULL,
	VERSION INTEGER NOT NULL,
	FILENAME VARCHAR(255) NOT NULL,
	NOTE VARCHAR(255),
	DATE_CREATE DATE,
 	DATETIME_UPDATE DATETIME AS NOW() NOT NULL,	
	ID_KONT BIGINT NOT NULL,
	CONSTRAINT PK_KONTDOC PRIMARY KEY (ID),
	CONSTRAINT FK_KONDOC_KONT FOREIGN KEY (ID_KONT) REFERENCES VIZMAN.KONT(ID) ON DELETE RESTRICT ON UPDATE RESTRICT
);

CREATE INDEX VIZMAN.IDX_KONTDOC ON VIZMAN.KONTDOC (FILENAME)
;

COMMIT;


DROP TABLE VIZMAN.ZAKDOC IF EXISTS;

CREATE TABLE VIZMAN.ZAKDOC (
	ID BIGINT NOT NULL,
	VERSION INTEGER NOT NULL,
	FILENAME VARCHAR(255) NOT NULL,
	NOTE VARCHAR(255),
	DATE_CREATE DATE,
 	DATETIME_UPDATE DATETIME AS NOW() NOT NULL,	
	ID_ZAK BIGINT NOT NULL,
	CONSTRAINT PK_ZAKDOC PRIMARY KEY (ID),
	CONSTRAINT FK_ZAKDOC_ZAK FOREIGN KEY (ID_ZAK) REFERENCES VIZMAN.ZAK(ID) ON DELETE RESTRICT ON UPDATE RESTRICT
);

CREATE INDEX VIZMAN.IDX_ZAKDOC ON VIZMAN.ZAKDOC (FILENAME)
;

COMMIT;


DROP TABLE VIZMAN.FAKT IF EXISTS;

CREATE TABLE VIZMAN.FAKT (
	ID BIGINT NOT NULL,
	VERSION INTEGER NOT NULL,
	TYP VARCHAR(5) NOT NULL DEFAULT 'FAKT',
	CFAKT INTEGER NOT NULL
			COMMENT 'Cislo fakturace unikatni pouze pro nadrazenou zakazku)',	
	PLNENI DECIMAL(4,1)
			COMMENT 'Fakturovane castecne plneni vyjadrene v procentech z pole ZAKLAD (nelze po vytvoreni zaznamu menit)',	
	DATE_DUZP DATE
			COMMENT 'Datum zdanitelneho plneni',	
	TEXT VARCHAR(128),
	ZAKLAD DECIMAL(19,2)
			COMMENT 'Honorar zakazky v okamziku vytvoreni fakturacniho zaznamu (nelze po vytvoreni zanzmau menit)',	
--	CASTKA DECIMAL(19,2) AS PLNENI * ZAKLAD / 100
	CASTKA DECIMAL(19,2)
	COMMENT 'Fakturovana castka vypocitana z poli PLNENI a ZAKLAD, zaokrouhlena na 2 destinna mista',	
	DATE_VYSTAV DATE
			COMMENT 'Datum vystavení fakturace',	
	DATETIME_EXPORT DATETIME
			COMMENT 'Datum a cas posledniho uspesneho exportu',	
	DATE_CREATE DATE NOT NULL,
	DATETIME_UPDATE DATETIME AS NOW() NOT NULL,
	ID_ZAK BIGINT NOT NULL,
	CONSTRAINT PK_FAKT PRIMARY KEY (ID),
	CONSTRAINT FK_FAKT_ZAK FOREIGN KEY (ID_ZAK) REFERENCES VIZMAN.ZAK(ID) ON DELETE RESTRICT ON UPDATE RESTRICT
);

CREATE UNIQUE INDEX VIZMAN.IDXQ_FAKT_IDZAK_CFAKT ON VIZMAN.FAKT (ID_ZAK, CFAKT)
;

COMMIT;



--  =============================================
--    MIGRATE DATA - KONT, ZAK, KLIENT
--  =============================================


-- !! POZOR, nejdriv zadat ROKMESZAD pro Režii v Zavinu !!


INSERT INTO VIZMAN.KLIENT
	(ID, VERSION, TYP, NAME, DATE_CREATE)
	SELECT DISTINCT
		VIZMAN.KLIENT_SEQ_IMP.NEXTVAL, 1, 'KLI', zak.FIRMA, NOW()
		FROM (SELECT DISTINCT firma FROM ZAVIN.ZAK_
				WHERE LENGTH(CISLO_ZAKAZKY) > 5 AND firma IS not NULL
				ORDER BY firma
			 ) zak
--		TO_DATE(CONCAT(ROKMESZAD, '-01'), 'YYYY-MM-DD'), FALSE FROM ZAVIN.ZAK_
--	WHERE LENGTH(CISLO_ZAKAZKY) > 5 AND cislo_zakazky IS not NULL
;

COMMIT;

CREATE UNIQUE INDEX VIZMAN.IDXQ_KLIENT_NAME ON VIZMAN.KLIENT (NAME)
;

COMMIT;



SELECT CISLO_ZAKAZKY, LENGTH(TEXT) AS LEN, TEXT
	FROM zavin.zak_
	ORDER BY LEN DESC
;

INSERT INTO VIZMAN.KONT
	(ID, VERSION, UUID, CKONT, ROK, TYP, MENA,
	TEXT,
--	OBJEDNATEL, DATE_CREATE, DATETIME_UPDATE, ARCH)
	OBJEDNATEL, DATE_CREATE, ARCH)
	SELECT
		VIZMAN.KONT_SEQ_IMP.NEXTVAL, 1, RANDOM_UUID(), CISLO_ZAKAZKY, ROKZAK, 'KONT', 'CZK',
		SUBSTR(
			(CASE WHEN CHARINDEX(CHAR(13), text) = CHARINDEX(CHAR(10), text) - 1 
				THEN SUBSTR(text, 0, CHARINDEX(CHAR(13), text) - 1)
				ELSE text
			END), 0, 127
		),
--		FIRMA, TO_DATE(CONCAT(ROKMESZAD, '-01'), 'YYYY-MM-DD'), DATUMIMP, FALSE FROM ZAVIN.ZAK_
		FIRMA, TO_DATE(CONCAT(ROKMESZAD, '-01'), 'YYYY-MM-DD'), FALSE FROM ZAVIN.ZAK_
	WHERE LENGTH(CISLO_ZAKAZKY) > 5 OR CISLO_ZAKAZKY = '00001'
;

COMMIT;


UPDATE VIZMAN.KONT ko
	SET ID_KLIENT = (SELECT ID FROM VIZMAN.KLIENT kl WHERE ko.OBJEDNATEL = kl.NAME)
;

COMMIT;


INSERT INTO VIZMAN.ZAK (ID, VERSION, UUID, CKONT_ORIG, CZAK, TYP,
                        ROK, ROKMESZAD,
                        TEXT,
                        HONORAR, ROZPRAC, ARCH,
                        R_ZAL, R1, R2, R3, R4, SKUPINA, RM,
--                        DATE_CREATE, DATETIME_UPDATE)
                        DATE_CREATE)
                        SELECT VIZMAN.ZAK_SEQ_IMP.NEXTVAL, 1, RANDOM_UUID(), CISLO_ZAKAZKY, 1, 'ZAK',
						ROKZAK, ROKMESZAD,
						SUBSTR (
							(CASE WHEN CHARINDEX(CHAR(13), text) = CHARINDEX(CHAR(10), text) - 1 
								THEN SUBSTR(text, CHARINDEX(CHAR(10), text) + 1)
								ELSE ''
							END), 0, 127
							),
						HONORAR, ROZPRAC, ARCH,
						R_ZAL, R1, R2, R3, R4, SKUPINA, RM,
--						TO_DATE(CONCAT(ROKMESZAD, '-01'), 'YYYY-MM-DD'), DATUMIMP
						TO_DATE(CONCAT(ROKMESZAD, '-01'), 'YYYY-MM-DD')
	FROM ZAVIN.ZAK_
	WHERE LENGTH(CISLO_ZAKAZKY) > 5 OR CISLO_ZAKAZKY = '00001'
;

COMMIT;


UPDATE VIZMAN.ZAK
	SET TEXT = REPLACE(TEXT, CONCAT (CHAR(13), CHAR(10)), ' ') 
	WHERE LENGTH(TEXT) > 0
;				


-- Kontrola: 

SELECT CKONT, LENGTH(TEXT) AS LEN, TEXT
	FROM vizman.kont
	ORDER BY LEN DESC
;

SELECT CKONT, LENGTH(TEXT) AS LEN, TEXT
	FROM vizman.kont
	WHERE CHARINDEX(CHAR(13), text) > 0
	ORDER BY LEN DESC
;

SELECT CKONT, LENGTH(TEXT) AS LEN, TEXT
	FROM vizman.kont
	WHERE CHARINDEX(CHAR(10), text) > 0
	ORDER BY LEN DESC
;


SELECT CKONT_ORIG, LENGTH(TEXT) AS LEN, TEXT
	FROM vizman.zak
	ORDER BY LEN DESC
;

SELECT CKONT_ORIG, LENGTH(TEXT) AS LEN, TEXT
	FROM vizman.zak
	WHERE CHARINDEX(CHAR(13), text) > 0
	ORDER BY LEN DESC
;

SELECT CKONT_ORIG, LENGTH(TEXT) AS LEN, TEXT
	FROM vizman.zak
	WHERE CHARINDEX(CHAR(10), text) > 0
	ORDER BY LEN DESC
;



-- !!!!!!!!!!!!!!!!!!!!!!!!!!!
-- POZOR, nastavit rucne TYP rezijni zakazky na REZ !!! 

SELECT count (*) FROM ZAVIN.ZAK_;
SELECT count (*) FROM VIZMAN.KONT;
SELECT count (*) FROM VIZMAN.ZAK;

UPDATE VIZMAN.ZAK AS zak
	SET zak.ID_KONT = (SELECT top 1 kont.ID FROM VIZMAN.KONT kont
		WHERE zak.CKONT_ORIG = kont.CKONT)
	WHERE zak.CKONT_ORIG IN (SELECT kont.CKONT from VIZMAN.KONT kont where kont.CKONT = kont.CKONT)
;

COMMIT;


-- CREATE UNIQUE INDEX IDXQ_ZAK ON VIZMAN.ZAK (CKONT, CZAK);

-- '58016.1-1'
INSERT INTO VIZMAN.ZAK
	(ID, VERSION, UUID, CKONT_ORIG, CZAK, TYP, ARCH, HONORAR, R1, R2, R3, R4, R_ZAL, RM, DATE_CREATE, DATETIME_UPDATE, ROKMESZAD, ROK, ROZPRAC, SKUPINA, TEXT, TMP, ID_KONT)
VALUES(21307, 1, RANDOM_UUID(), NULL, 2, 'ZAK', false, 200000.00, 0.00, 0.00, 0.00, 0.00, 0, 0.00, '2016-06-01', '2016-06-24', '2016-06', 2016, 0.00, '1', 'Ausführungsplanung Fussgängerbrücke II', NULL, 11305)
;

INSERT INTO VIZMAN.ZAK
	(ID, VERSION, UUID, CKONT_ORIG, CZAK, TYP, ARCH, HONORAR, R1, R2, R3, R4, R_ZAL, RM, DATE_CREATE, DATETIME_UPDATE, ROKMESZAD, ROK, ROZPRAC, SKUPINA, TEXT, TMP, ID_KONT)
VALUES(21308, 1, RANDOM_UUID(), NULL, 3, 'AKV', false, 0.00, 0.00, 0.00, 0.00, 0.00, 0, 0.00, '2016-06-01', '2016-06-24', '2016-06', 2016, 0.00, '1', 'Ausführungsplanung Fussgängerbrücke II', NULL, 11305)
;

INSERT INTO VIZMAN.ZAK
	(ID, VERSION, UUID, CKONT_ORIG, CZAK, TYP, ARCH, HONORAR, R1, R2, R3, R4, R_ZAL, RM, DATE_CREATE, DATETIME_UPDATE, ROKMESZAD, ROK, ROZPRAC, SKUPINA, TEXT, TMP, ID_KONT)
VALUES(21309, 1, RANDOM_UUID(), NULL, 5, 'ZAK', false, 15000.00, 0.00, 0.00, 0.00, 0.00, 0, 0.00, '2016-06-01', '2016-06-24', '2016-06', 2016, 0.00, '1', 'Ausführungsplanung Fussgängerbrücke III', NULL, 11305)
;


--update tlegacy lca set 
--  lca.pr_dato = (select ca.calc_holdings_date ... from tca ca where ...)
--  where lca.id in (select ca.id from tca where ...)


-- ALTER TABLE VIZMAN.ZAK
--	ADD FOREIGN KEY (ID_KONT) REFERENCES VIZMAN.KONT(ID);

COMMIT;


-- ----------------------------------------------------------


INSERT INTO VIZMAN.FAKT
	(ID, VERSION, TYP, CFAKT, PLNENI, ZAKLAD, CASTKA, TEXT, DATE_DUZP, DATE_CREATE, DATETIME_UPDATE, ID_ZAK)
VALUES(500001, 1, 'FAKT', 1, 31.0, 200000.00, 62000.00, 'Plneni I.', '2019-01-20', '2018-12-29', '2018-12-29', 21307)
;

INSERT INTO VIZMAN.FAKT
	(ID, VERSION, TYP, CFAKT, PLNENI, ZAKLAD, CASTKA, TEXT, DATE_DUZP, DATE_CREATE, DATETIME_UPDATE, ID_ZAK)
VALUES(500002, 1, 'FAKT', 2, 69.0, 200000.00, 138000.00, 'Plneni II.', '2019-01-21', '2018-12-28', '2018-12-29', 21307)
;

INSERT INTO VIZMAN.FAKT
	(ID, VERSION, TYP, CFAKT, PLNENI, ZAKLAD, CASTKA, TEXT, DATE_DUZP, DATE_CREATE, DATETIME_UPDATE, ID_ZAK)
VALUES(500003, 1, 'SUB', 3, null, NULL,    -30000.00, 'Montýrung, demontýrung', NULL, '2019-01-20', '22019-01-20', 21307)
;


COMMIT;





--  =============================================
--    CREATE TABLES - DOCH a spol.
--  =============================================


DROP TABLE VIZMAN.DOCH IF EXISTS;

DROP SEQUENCE VIZMAN.DOCH_SEQ IF EXISTS;


CREATE TABLE VIZMAN.DOCH (
	ID BIGINT NOT NULL,
	VERSION INTEGER NOT NULL,
	PERSON_ID BIGINT NOT NULL,
	USERNAME VARCHAR(32),
--	USER_EDIT_AD VARCHAR(20),

--	D_YEAR SMALLINT,
--	D_MONTH SMALLINT,
--	D_DAY SMALLINT,
--	D_ROKMES VARCHAR(7),
	DOCH_DATE DATE,
	CDOCH INTEGER NOT NULL,
	DOCH_STATE VARCHAR(2),
--	D_DK VARCHAR(2),
	FROM_TIME TIME,
	FROM_MODIF_DATETIME TIMESTAMP,
	FROM_MANUAL BOOLEAN,
	TO_TIME TIME,
	TO_MODIF_DATETIME TIMESTAMP,
	TO_MANUAL BOOLEAN,
	DOCH_DURATION TIME,
	DOCH_DUR BIGINT,

	CIN_ID INTEGER,
--	CIN_ST VARCHAR(2),
	CIN_AKCE_TYP VARCHAR(2),
	CIN_CIN_KOD VARCHAR(2),
	CINNOST VARCHAR(24),

	CALCPRAC BOOLEAN,
	POZNAMKA VARCHAR(120),
	TMP VARCHAR(1),
--	M_DATCAS TIMESTAMP,
	CONSTRAINT PK_DOCH PRIMARY KEY (ID)
);

COMMIT;



--  =============================================
--    MIGRATE DATA - DOCH a spol.
--  =============================================

-- (DOCH_ID, USER_LOGIN, USER_EDIT_AD, D_YEAR, D_MONTH, D_DAY, D_ROKMES, D_DATUM, D_DK, Z_DATCASOD, D_CAS_OD, R_OD, Z_DATCASDO, D_CAS_DO, R_DO, D_HODIN, CIN_ID, CIN_POL, CIN_ST, CIN_T1, CIN_T2, CINNOST, CALCPRAC, POZNAMKA, TMP, M_DATCAS)

INSERT INTO VIZMAN.DOCH
  (ID, VERSION, PERSON_ID, USERNAME, DOCH_DATE,
  FROM_MODIF_DATETIME, FROM_TIME, FROM_MANUAL,
  TO_MODIF_DATETIME, TO_TIME, TO_MANUAL,
  DOCH_DURATION, DOCH_DUR,
  DOCH_STATE,
  CIN_ID, CDOCH,
  CIN_AKCE_TYP, CIN_CIN_KOD, CINNOST, CALCPRAC, POZNAMKA, TMP)
SELECT
  DOCH_ID, 1, 0, USER_LOGIN, D_DATUM,
  Z_DATCASOD, D_CAS_OD,
  CASE
    WHEN R_OD = 1 THEN TRUE
    ELSE FALSE
  END,
  Z_DATCASDO, D_CAS_DO,
  CASE
    WHEN R_DO = 1 THEN TRUE
    ELSE FALSE
  END,
--  D_HODIN, TIMESTAMPDIFF(SECOND, D_CAS_OD, D_CAS_DO) * 1000 * 1000 *1000,
  D_HODIN, TIMESTAMPDIFF(SECOND, PARSEDATETIME('1899-12-30 00:00','yyyy-MM-dd HH:mm'), D_HODIN) * 1000 * 1000 * 1000,
  CASE
    WHEN CIN_ST = 'K' THEN 'K'
    ELSE NULL
  END,
  CIN_ID, CIN_POL,
  CIN_T1, CIN_T2, CINNOST, CALCPRAC, POZNAMKA, TMP
FROM ZAVIN.DOCH_
;

COMMIT;

SELECT count (DOCH_ID) FROM ZAVIN.DOCH_;
SELECT count (ID) FROM VIZMAN.DOCH;


-- Set PERSON IDs:
UPDATE VIZMAN.DOCH AS doch
SET doch.PERSON_ID = (SELECT top 1 PERSON.ID FROM VIZMAN.PERSON person
		WHERE DOCH.USERNAME = PERSON.USERNAME)
WHERE doch.USERNAME IN (SELECT person.USERNAME from VIZMAN.PERSON person where person.USERNAME = doch.USERNAME)
;

COMMIT;


-- Make half day dovolena kod different from unique:
UPDATE VIZMAN.DOCH AS doch
SET doch.CIN_CIN_KOD = 'dp'
	WHERE DOCH.CIN_CIN_KOD = 'do' AND DOCH.DOCH_STATE IS NULL
;

COMMIT;


-- Make half day dovolena kod different from full day:
UPDATE VIZMAN.DOCH AS doch
SET doch.CIN_CIN_KOD = 'dc'
	WHERE DOCH.CIN_CIN_KOD = 'do' AND DOCH.DOCH_STATE IS NULL
;

COMMIT;


UPDATE VIZMAN.DOCH AS doch
SET doch.CIN_AKCE_TYP = 'F'
	WHERE DOCH.CIN_CIN_KOD = 'dc' OR DOCH.CIN_CIN_KOD = 'dp' OR DOCH.CIN_CIN_KOD = 'ne' OR DOCH.CIN_CIN_KOD = 'nv'
;

COMMIT;

UPDATE VIZMAN.DOCH AS doch
SET doch.CIN_AKCE_TYP = 'A'
	WHERE DOCH.CIN_CIN_KOD = 'OA'
;

UPDATE VIZMAN.DOCH AS doch
SET doch.CALCPRAC = true
	WHERE DOCH.CIN_CIN_KOD = 'OA'
;

COMMIT;




CREATE INDEX VIZMAN.IDX_DOCH_PERSONID_DOCHDATE_FROM_TIME ON VIZMAN.DOCH (PERSON_ID, DOCH_DATE, FROM_TIME)
;

COMMIT;




-- =================================================
--  DOCHSUM, DOCHSUM_ZAK, DOCHSUM_PARAG
-- =================================================

-- ----- DELETE vykony s nulovym dnem a s nulovou praci
 
-- 168 849
SELECT count(*) FROM ZAVIN.VYKONY_
WHERE 
	(
		CISLO_ZAKAZKY = '00002'
		OR CISLO_ZAKAZKY = '00005'
		OR CISLO_ZAKAZKY = '00006'
		OR CISLO_ZAKAZKY = '00007'
		OR CISLO_ZAKAZKY = '00008'
	)
	AND
	(
		PRAC_DEN = 0
		OR ODPRAC_HOD = 0
	)
;

-- 173 344
SELECT count(*) FROM ZAVIN.VYKONY_
WHERE
	ODPRAC_HOD = 0
	AND PRAC_DEN = 0
;

DELETE FROM ZAVIN.VYKONY_
WHERE 
	PRAC_DEN = 0
	AND ODPRAC_HOD = 0
;

COMMIT;

-- 0
SELECT count(*) FROM ZAVIN.VYKONY_
WHERE
	ODPRAC_HOD = 0
	AND PRAC_DEN = 0
;

-- 0
SELECT count(*) FROM ZAVIN.VYKONY_
WHERE
	ODPRAC_HOD = 0
;

-- 106
SELECT count(*) FROM ZAVIN.VYKONY_
WHERE 
	CISLO_ZAKAZKY = '00002'
	AND USER_LOGIN = 'Koutska'
;


SELECT * FROM ZAVIN.VYKONY_
WHERE 
	CISLO_ZAKAZKY = '00002'
	AND USER_LOGIN = 'Koutska'
ORDER BY PRAC_ROK DESC, PRAC_MES DESC, PRAC_DEN DESC
;



-- ----- DOCHSUM -----------

-- 35 933
SELECT count(*) FROM ZAVIN.DOCH_SUM;
-- 63 127
SELECT count(*) FROM ZAVIN.VYKONY_;

DROP TABLE VIZMAN.DOCHSUM IF EXISTS;

CREATE TABLE VIZMAN.DOCHSUM (
	ID BIGINT NOT NULL,
	VERSION INTEGER NOT NULL,	
	PERSON_ID BIGINT NOT NULL,
	DS_DATE DATE NOT NULL,
	DS_YM INTEGER NOT NULL,

--	DS_ROKMES VARCHAR(7),
--	DS_YEAR SMALLINT,
--	DS_MONTH SMALLINT,
--	DS_DAY SMALLINT,
	
	USERNAME VARCHAR(32),
--	DS_DK VARCHAR(2),

	DS_FROM_FIRST TIMESTAMP,
	DS_TO_LAST TIMESTAMP,
	
--	DS_PRAC TIMESTAMP,
	DS_WORK DECIMAL(5,2),

--	DS_PRACKR TIMESTAMP,
	DS_WORK_RED DECIMAL(5,2),

--	DS_PRUH TIMESTAMP,
	DS_WORK_PRUH DECIMAL(5,2),

--	DS_OBEDOA TIMESTAMP,
	DS_OBED_AUT DECIMAL(5,2),

	OBED_KRATKY BOOLEAN,

--	DS_OBEDMO TIMESTAMP,
	DS_OBED_MAN DECIMAL(5,2),

--	DS_OBED TIMESTAMP,
	DS_OBED DECIMAL(5,2),	
	
--	DS_NEM TIMESTAMP,
	DS_NEM DECIMAL(5,2),

--	DS_DOV TIMESTAMP,
	DS_DOV DECIMAL(5,2),

--	DS_LEK TIMESTAMP,
	DS_LEK DECIMAL(5,2),

--	DS_VOL TIMESTAMP,
	DS_VOL DECIMAL(5,2),

--	DS_NA_HOD TIMESTAMP,
	DS_NA DECIMAL(5,2),
	DS_NA_DATUM Date,

--	DS_VIK TIMESTAMP,
	DS_VIK DECIMAL(5,2),
	
	RS BOOLEAN,

--	POZNAMKA VARCHAR(120),
	TMP VARCHAR(1),
	
	CONSTRAINT PK_DOCHSUM PRIMARY KEY (ID)
);

COMMIT;


INSERT INTO VIZMAN.DOCHSUM (
	ID, VERSION, PERSON_ID, DS_DATE,
	DS_YM,
	USERNAME,
	DS_FROM_FIRST, DS_TO_LAST,
	DS_WORK, DS_WORK_RED, DS_WORK_PRUH,
	DS_OBED_MAN, DS_OBED_AUT, OBED_KRATKY, DS_OBED,
	DS_NEM, DS_DOV, DS_LEK, DS_VOL,
	DS_NA, DS_NA_DATUM, DS_VIK, RS
)
SELECT
	DOCHSUM_ID, 0, 0, DS_DATUM,
	100 * CONVERT(SUBSTRING(CONVERT(DS_DATUM, VARCHAR(10)), 1, 4), INTEGER) + CONVERT(SUBSTRING(CONVERT(DS_DATUM, VARCHAR(10)), 6, 2), INTEGER),
	USER_LOGIN,
	DS_ODFIRST, DS_DOLAST,
	DS_PRACDEC, DS_PRACKRDEC, DS_PRUHDEC,
	DS_OBEDMODEC, DS_OBEDOADEC, OBEDKRATKY, DS_OBEDDEC,
	DS_NEMDEC, DS_DOVDEC, DS_LEKDEC, DS_VOLDEC,
	DS_NA_HODDEC, DS_NA_DATUM, DS_VIKDEC, RS
FROM ZAVIN.DOCH_SUM
;

COMMIT;



UPDATE VIZMAN.DOCHSUM AS dochsum
SET dochsum.PERSON_ID = (SELECT top 1 PERSON.ID FROM VIZMAN.PERSON person
		WHERE DOCHSUM.USERNAME = PERSON.USERNAME)
WHERE dochsum.USERNAME IN (SELECT person.USERNAME from VIZMAN.PERSON person where person.USERNAME = dochsum.USERNAME)
;

COMMIT;

-- Kontrola duplicit:
SELECT *
FROM vizman.dochsum
WHERE person_id || '===' || ds_date IN (
SELECT person_id || '===' || ds_date
FROM
	(SELECT
    	person_id, ds_date, COUNT(*)
	FROM
    	vizman.dochsum
	GROUP BY
    	person_id, ds_date
	HAVING 
    	COUNT(*) > 1
	)
)
;


-- !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
--    BACHA
-- !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
DELETE FROM vizman.dochsum 
WHERE ID IN
(SELECT ID
FROM vizman.dochsum
WHERE person_id || '===' || ds_date IN (
SELECT person_id || '===' || ds_date
FROM
	(SELECT
    	person_id, ds_date, COUNT(*)
	FROM
    	vizman.dochsum
	GROUP BY
    	person_id, ds_date
	HAVING 
    	COUNT(*) > 1
	)
)
)
;


COMMIT;

CREATE UNIQUE INDEX IDXQ_DOCHSUM_PERSON_DATE ON VIZMAN.DOCHSUM (PERSON_ID, DS_DATE);


-- Kontrola automatickych obedu:
SELECT DISTINCT CIN_CIN_KOD, count(*) FROM VIZMAN.DOCH
	WHERE DOCH_STATE = 'K' AND cin_cin_kod <> 'OA'
	GROUP BY CIN_CIN_KOD
;

SELECT COUNT(*) FROM VIZMAN.DOCH
	WHERE DOCH_STATE = 'K' AND CIN_CIN_KOD = 'OA'
	GROUP BY CIN_CIN_KOD
;

UPDATE VIZMAN.DOCH
	SET DOCH_DUR = - DOCH_DUR
	WHERE CIN_CIN_KOD = 'OA'
;

COMMIT;

SELECT COUNT(*) FROM VIZMAN.DOCH
	WHERE CIN_CIN_KOD = 'OA' AND DOCH_DUR > 0
;



--	DS_DK, , DS_PRAC,  DS_PRACKR,  DS_PRUH,  DS_NEM,  DS_DOV,  DS_LEK,  DS_VOL, DS_NA_HOD, 
--	DS_ROKMES, DS_YEAR, DS_MONTH, DS_DAY,  POZNAMKA, TMP, DS_OBEDOA, , DS_OBEDMO, DS_OBEDMODEC, DS_OBED,  DS_VIK)



DROP TABLE VIZMAN.DOCHSUM_ZAK IF EXISTS;

CREATE TABLE VIZMAN.DOCHSUM_ZAK (
	ID BIGINT NOT NULL,
	VERSION INTEGER NOT NULL,
	PERSON_ID BIGINT NOT NULL,
	DS_DATE DATE NOT NULL,
	DS_YM INTEGER NOT NULL,
	ZAK_ID BIGINT NOT NULL,
	CKONT_ORIG VARCHAR(16),
	USERNAME VARCHAR(32),
	DS_WORK DECIMAL(5,2),
	DS_WORK_NORM DOUBLE,
	DS_MZDA DECIMAL(8,2),
	DS_POJIST DECIMAL(8,2),
	DS_MZDAS DECIMAL(8,2),
	DS_POJISTS DECIMAL(8,2),
	SAZBA DECIMAL(7,2),
	TMP VARCHAR(1),
	CONSTRAINT PK_DOCHSUMZAK PRIMARY KEY (ID)
);

COMMIT;

SELECT count(*) FROM VIZMAN.DOCHSUM;
SELECT count(*) FROM VIZMAN.DOCHSUM_ZAK;

SELECT count(*) FROM ZAVIN.DOCH_SUM;
SELECT count(*) FROM ZAVIN.VYKONY_;



SELECT count(*)
FROM ZAVIN.VYKONY_
WHERE LENGTH(CISLO_ZAKAZKY) > 5 AND PRAC_DEN = 0
;

DELETE 
FROM ZAVIN.VYKONY_
WHERE LENGTH(CISLO_ZAKAZKY) > 5 AND PRAC_DEN = 0
;

COMMIT;

SELECT count(*)
FROM ZAVIN.VYKONY_
WHERE LENGTH(CISLO_ZAKAZKY) > 5 AND PRAC_DEN = 0
;


INSERT INTO VIZMAN.DOCHSUM_ZAK (
	ID,	VERSION, PERSON_ID,
	DS_DATE,
	DS_YM,
	ZAK_ID,	CKONT_ORIG, USERNAME,
	DS_WORK, DS_WORK_NORM,
	DS_MZDA, DS_POJIST,
	DS_MZDAS, DS_POJISTS,
	SAZBA
)
SELECT
	VYK_ZAK_ID, 0, 0,
	CONVERT(CONCAT(CONVERT(PRAC_ROK, VARCHAR(4)), '-', CONVERT(PRAC_MES, VARCHAR(2)), '-', CONVERT(PRAC_DEN, VARCHAR(2))), DATE),
	(100 * PRAC_ROK) + PRAC_MES,
	0, CISLO_ZAKAZKY, USER_LOGIN,
	ODPRAC_HOD, NORM_HOD, MZDA, POJISTENI, MZDAS, POJISTS, SAZBA
FROM ZAVIN.VYKONY_
-- WHERE (LENGTH(CISLO_ZAKAZKY) > 5) 
WHERE (LENGTH(CISLO_ZAKAZKY) > 5 OR (CISLO_ZAKAZKY = '00001')) AND PRAC_DEN <> 0
;

COMMIT;

UPDATE VIZMAN.DOCHSUM_ZAK AS dz
SET dz.PERSON_ID = (SELECT top 1 ID FROM VIZMAN.PERSON p1
		WHERE dz.USERNAME = p1.USERNAME)
WHERE dz.USERNAME IN (SELECT p2.USERNAME from VIZMAN.PERSON p2 where p2.USERNAME = dz.USERNAME)
;

COMMIT;

UPDATE VIZMAN.DOCHSUM_ZAK AS dz
SET dz.ZAK_ID = (SELECT top 1 ID FROM VIZMAN.ZAK z1
		WHERE dz.CKONT_ORIG = z1.CKONT_ORIG)
WHERE dz.CKONT_ORIG IN (SELECT z2.CKONT_ORIG from VIZMAN.ZAK z2 where z2.CKONT_ORIG = dz.CKONT_ORIG)
;

COMMIT;


-- Kontroly:

SELECT *
FROM zavin.VYKONY_
WHERE USER_LOGIN = 'Vancik' AND NORM_HOD = 0
ORDER BY ROKMES DESC
;

SELECT count(*)
FROM zavin.VYKONY_
WHERE USER_LOGIN = 'Vancik' AND NORM_HOD = 0
;

SELECT count(*)
FROM zavin.VYKONY_
WHERE NORM_HOD = 0
;

SELECT *
FROM vizman.DOCHSUM_ZAK
WHERE DS_WORK_NORM = 0
;


-- Kontroly duplicit:

SELECT count(*)
FROM VIZMAN.DOCHSUM_ZAK
WHERE (PERSON_ID IS NULL) OR PERSON_ID = 0
;

SELECT count(*)
FROM VIZMAN.DOCHSUM_ZAK
WHERE (ZAK_ID IS NULL) OR ZAK_ID = 0
;

SELECT count(*)
FROM VIZMAN.DOCHSUM_ZAK
WHERE DS_DATE IS NULL
;

SELECT ID
FROM vizman.dochsum_zak
WHERE person_id || '===' || ds_date || '===' ||  zak_id IN (
SELECT person_id || '===' || ds_date || '===' || zak_id
FROM
	(SELECT
    	person_id, ds_date, zak_id, COUNT(*)
	FROM
    	vizman.dochsum_zak
	GROUP BY
    	person_id, ds_date,  zak_id
	HAVING 
    	COUNT(*) > 1
	)
)
;

-- ?? Kam zmizela REZIE ??
DELETE FROM VIZMAN.DOCHSUM_ZAK
WHERE ID IN 
(SELECT ID
FROM vizman.dochsum_zak
WHERE person_id || '===' || ds_date || '===' ||  zak_id IN (
SELECT person_id || '===' || ds_date || '===' || zak_id
FROM
	(SELECT
    	person_id, ds_date, zak_id, COUNT(*)
	FROM
    	vizman.dochsum_zak
	GROUP BY
    	person_id, ds_date,  zak_id
	HAVING 
    	COUNT(*) > 1
	)
)
)
;


CREATE UNIQUE INDEX IDXQ_DOCHSUMZAK_PERSON_DATE_ZAK ON VIZMAN.DOCHSUM_ZAK (PERSON_ID, DS_DATE, ZAK_ID);
	
COMMIT;

SELECT count(*) FROM VIZMAN.DOCHSUM;
SELECT count(*) FROM ZAVIN.DOCH_SUM;
SELECT count(*) FROM VIZMAN.DOCHSUM_ZAK;
SELECT count(*) FROM ZAVIN.VYKONY_;


-- --------- DOCHSUM_PARAG --------------

DROP TABLE VIZMAN.PARAG IF EXISTS;

CREATE TABLE VIZMAN.PARAG (
	ID BIGINT NOT NULL,
	VERSION INTEGER NOT NULL,
	TYP VARCHAR(5),
	CPARAG VARCHAR(16),
	TEXT VARCHAR(127),
	DATE_CREATE DATE,
	DATETIME_UPDATE DATETIME AS NOW() NOT NULL,
	CONSTRAINT PK_PARAG PRIMARY KEY (ID)
);

CREATE UNIQUE INDEX IDXQ_PARAGM_CPARAG ON VIZMAN.PARAG (CPARAG);

INSERT INTO VIZMAN.PARAG (ID, VERSION, TYP, CPARAG, TEXT,  DATE_CREATE)
values(120, 1, 'PARAG', '00002', 'Dovolená', TO_DATE('2000-01-01', 'yyyy-MM-dd'));
INSERT INTO VIZMAN.PARAG (ID, VERSION, TYP, CPARAG, TEXT,  DATE_CREATE)
values(140, 1, 'PARAG', '00004', 'Lékaø', TO_DATE('2000-01-01', 'yyyy-MM-dd'));
INSERT INTO VIZMAN.PARAG (ID, VERSION, TYP, CPARAG, TEXT,  DATE_CREATE)
values(150, 1, 'PARAG', '00005', 'Svátek', TO_DATE('2000-01-01', 'yyyy-MM-dd'));
INSERT INTO VIZMAN.PARAG (ID, VERSION, TYP, CPARAG, TEXT,  DATE_CREATE)
values(160, 1, 'PARAG', '00006', 'Nemoc, OÈR', TO_DATE('2000-01-01', 'yyyy-MM-dd'));
INSERT INTO VIZMAN.PARAG (ID, VERSION, TYP, CPARAG, TEXT,  DATE_CREATE)
values(170, 1, 'PARAG', '00007', 'OÈR (starý zpùsob)', TO_DATE('2000-01-01', 'yyyy-MM-dd'));
INSERT INTO VIZMAN.PARAG (ID, VERSION, TYP, CPARAG, TEXT,  DATE_CREATE)
values(180, 1, 'PARAG', '00008', 'Neplacené volno', TO_DATE('2000-01-01', 'yyyy-MM-dd'));

COMMIT;

DROP TABLE VIZMAN.DOCHSUM_PARAG IF EXISTS;

CREATE TABLE VIZMAN.DOCHSUM_PARAG (
	ID BIGINT NOT NULL,
	VERSION INTEGER NOT NULL,
	PERSON_ID BIGINT NOT NULL,
	DS_DATE DATE NOT NULL,
	DS_YM INTEGER NOT NULL,
	PARAG_ID BIGINT NOT NULL,
	CPARAG VARCHAR(16),
	USERNAME VARCHAR(32),
	DS_WORK_OFF DECIMAL(5,2),
	CONSTRAINT PK_DOCHSUMPARAG PRIMARY KEY (ID)
);

COMMIT;


INSERT INTO VIZMAN.DOCHSUM_PARAG (
	ID,	VERSION, PERSON_ID,
	DS_DATE,
	DS_YM,
	PARAG_ID, CPARAG, USERNAME,
	DS_WORK_OFF
)
SELECT
	VYK_ZAK_ID, 0, 0,
	CONVERT(CONCAT(CONVERT(PRAC_ROK, VARCHAR(4)), '-', CONVERT(PRAC_MES, VARCHAR(2)), '-', CONVERT(PRAC_DEN, VARCHAR(2))), DATE),
	(100 * PRAC_ROK) + PRAC_MES,
	0, CISLO_ZAKAZKY, USER_LOGIN,
	ODPRAC_HOD
FROM ZAVIN.VYKONY_
WHERE 
	CISLO_ZAKAZKY = '00002'
	OR CISLO_ZAKAZKY = '00005'
	OR CISLO_ZAKAZKY = '00006'
	OR CISLO_ZAKAZKY = '00007'
	OR CISLO_ZAKAZKY = '00008'
;

COMMIT;


-- Insert from ZAVIN.DOCH_  (since 20015)

-- ZK	P
-- ZK	MO
-- 		OA
-- 		ne
-- 		nv
-- 		do
-- ZK	L
-- ZK	PM
SELECT DISTINCT CIN_T1, CIN_T2 FROM ZAVIN.DOCH_
;

-- 2019	L	1
-- 2019	do	1
-- 2018	do	213
-- 2018	L	46
-- 2018	ne	9
-- 2017	L	39
-- 2017	nv	4
-- 2017	do	196
-- 2017	ne	22
-- 2016	ne	45
-- 2016	L	45
-- 2016	nv	16
-- 2016	do	206
-- 2015	nv	16
-- 2015	L	63
-- 2015	do	227
-- 2015	ne	23
SELECT D_YEAR, CIN_T2, count(*) FROM ZAVIN.DOCH_
WHERE 
 	CIN_T2 = 'do' OR CIN_T2 = 'dp' OR CIN_T2 = 'ne' OR CIN_T2 = 'nv' OR CIN_T2 = 'L'
GROUP BY D_YEAR, CIN_T2
ORDER BY D_YEAR DESC
;

-- Dovolena - novy zpusob
INSERT INTO VIZMAN.DOCHSUM_PARAG (
	ID,	VERSION, PERSON_ID,
	DS_DATE,
	DS_YM,
	PARAG_ID,
	CPARAG,
	USERNAME,
	DS_WORK_OFF
)
SELECT
	DOCH_ID + 1500000, 0, 0,
	CONVERT(CONCAT(CONVERT(D_YEAR, VARCHAR(4)), '-', CONVERT(D_MONTH, VARCHAR(2)), '-', CONVERT(D_DAY, VARCHAR(2))), DATE),
	(100 * D_YEAR) + D_MONTH,
	0,
	'00002',
	USER_LOGIN,
	CONVERT((TIMESTAMPDIFF(SECOND, PARSEDATETIME('1899-12-30 00:00','yyyy-MM-dd HH:mm'), D_HODIN) / 3600.0), DECIMAL(5,1)) 
FROM ZAVIN.DOCH_
WHERE 
	CIN_T2 = 'do'
;

COMMIT;

--WHERE 
-- 	CIN_T2 = 'do' OR CIN_T2 = 'dp' OR CIN_T2 = 'ne' OR CIN_T2 = 'nv' OR CIN_T2 = 'L'
--	CISLO_ZAKAZKY = '00002'
--	OR CISLO_ZAKAZKY = '00005'
--	OR CISLO_ZAKAZKY = '00006'
--	OR CISLO_ZAKAZKY = '00007'
--	OR CISLO_ZAKAZKY = '00008'
--;


-- Lekar - novy zpusob
INSERT INTO VIZMAN.DOCHSUM_PARAG (
	ID,	VERSION, PERSON_ID,
	DS_DATE,
	DS_YM,
	PARAG_ID,
	CPARAG,
	USERNAME,
	DS_WORK_OFF
)
SELECT
	DOCH_ID + 1500000, 0, 0,
	CONVERT(CONCAT(CONVERT(D_YEAR, VARCHAR(4)), '-', CONVERT(D_MONTH, VARCHAR(2)), '-', CONVERT(D_DAY, VARCHAR(2))), DATE),
	(100 * D_YEAR) + D_MONTH,
	0,
	'00004',
	USER_LOGIN,
	CONVERT((TIMESTAMPDIFF(SECOND, PARSEDATETIME('1899-12-30 00:00','yyyy-MM-dd HH:mm'), D_HODIN) / 3600.0), DECIMAL(5,1)) 
FROM ZAVIN.DOCH_
WHERE 
	CIN_T2 = 'L'
;

COMMIT;


-- Nemoc, OCR - novy zpusob
INSERT INTO VIZMAN.DOCHSUM_PARAG (
	ID,	VERSION, PERSON_ID,
	DS_DATE,
	DS_YM,
	PARAG_ID,
	CPARAG,
	USERNAME,
	DS_WORK_OFF
)
SELECT
	DOCH_ID + 1500000, 0, 0,
	CONVERT(CONCAT(CONVERT(D_YEAR, VARCHAR(4)), '-', CONVERT(D_MONTH, VARCHAR(2)), '-', CONVERT(D_DAY, VARCHAR(2))), DATE),
	(100 * D_YEAR) + D_MONTH,
	0,
	'00006',
	USER_LOGIN,
	CONVERT((TIMESTAMPDIFF(SECOND, PARSEDATETIME('1899-12-30 00:00','yyyy-MM-dd HH:mm'), D_HODIN) / 3600.0), DECIMAL(5,1)) 
FROM ZAVIN.DOCH_
WHERE 
	CIN_T2 = 'ne'
;

COMMIT;


-- Nahradni volno - novy zpusob
INSERT INTO VIZMAN.DOCHSUM_PARAG (
	ID,	VERSION, PERSON_ID,
	DS_DATE,
	DS_YM,
	PARAG_ID,
	CPARAG,
	USERNAME,
	DS_WORK_OFF
)
SELECT
	DOCH_ID + 1500000, 0, 0,
	CONVERT(CONCAT(CONVERT(D_YEAR, VARCHAR(4)), '-', CONVERT(D_MONTH, VARCHAR(2)), '-', CONVERT(D_DAY, VARCHAR(2))), DATE),
	(100 * D_YEAR) + D_MONTH,
	0,
	'00008',
	USER_LOGIN,
	CONVERT((TIMESTAMPDIFF(SECOND, PARSEDATETIME('1899-12-30 00:00','yyyy-MM-dd HH:mm'), D_HODIN) / 3600.0), DECIMAL(5,1)) 
FROM ZAVIN.DOCH_
WHERE 
	CIN_T2 = 'nv'
;

COMMIT;




-- Update person IDs
UPDATE VIZMAN.DOCHSUM_PARAG AS dp
SET dp.PERSON_ID = (SELECT top 1 ID FROM VIZMAN.PERSON p1
		WHERE dp.USERNAME = p1.USERNAME)
WHERE dp.USERNAME IN (SELECT p2.USERNAME from VIZMAN.PERSON p2 where p2.USERNAME = dp.USERNAME)
;

COMMIT;

-- Update parag IDs
UPDATE VIZMAN.DOCHSUM_PARAG AS dp
SET dp.PARAG_ID = (SELECT top 1 ID FROM VIZMAN.PARAG p1
		WHERE dp.CPARAG = p1.CPARAG)
WHERE dp.CPARAG IN (SELECT p2.CPARAG from VIZMAN.PARAG p2 where p2.CPARAG = dp.CPARAG)
;

COMMIT;

CREATE UNIQUE INDEX IDXQ_DOCHSUMPARAG_PERSON_DATE_PARAG ON VIZMAN.DOCHSUM_PARAG (PERSON_ID, DS_DATE, PARAG_ID);

COMMIT;
